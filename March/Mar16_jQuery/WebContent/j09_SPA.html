<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Insert title here</title>
<script type="text/javascript" src="jQuery.js"></script>
<script type="text/javascript">

	// SPA(Single Page Application)
	//		사이트 전체가 한 페이지로 되어있음 (스크롤 기반으로 되어있는 게 특징)
	
	// DOM객체의 실제 위치(좌표) <- .offset().??? 으로 가져올 수 있음 .left, .top ...
	// 스크롤을 다룰 거라서 .top을 사용
	
	function jumpToJS() {
		var jsOffsetTop = $("#js").offset().top;
		$("#jsBtn").click(function() {
			$(window).scrollTop(jsOffsetTop - 70);
		});
	}

	function jumpToJava() { // 순간이동 방식
		$("#javaBtn").click(function() {
			$(window).scrollTop($("#java").offset().top - 70);
		});
	}
	
	function jumpToPython() { // 애니메이션 들어간 방식
		$("#pythonBtn").click(function() {
			$("html").animate({
				scrollTop : $("#python").offset().top - 70
			}, 500);
		});
	}

	$(function() {
		jumpToJS();
		jumpToJava();
		jumpToPython();
	});
</script>
<style type="text/css">
body {
	padding-top: 50px;
}

table {
	position: fixed;
	width: 100%;
	height: 50px;
	top: 0px;
	left: 0px;
	background-color: white;
	text-align: center;
}
</style>
</head>
<body>
	<h2>설명</h2>
	<table>
		<tr>
			<td id="jsBtn">JavaScript</td>
			<td id="javaBtn">Java</td>
			<td id="pythonBtn">Python</td>
		</tr>
	</table>
	<h1 id="js">JavaScript</h1>
	부모 자식의 구분도 없으며, 메인 메소드 같은 것도 없고, 클래스-인스턴스 관계도 없으며, 모든 함수가 클래스도 될 수 있으며
	인스턴스도 될 수 있다. 그렇기 때문에 모든 함수가 따로 놀기에 따라서 객체 지향처럼 "서로 맞물리는" 것을 기대할 수도
	없다.(그런 이유로 클로저 개념이 있다.) 이 특성을 잘 이해해야 한다. 오히려 순서대로 읽는 절차 지향/객체 지향 언어보다는
	모든 요소가 각자 따로 움직이는 스타크래프트 맵 에디터 스크립트에 더 가까운 개념으로 이해해야 한다. 로드는 순서대로지만 실행은
	동시 실행이다. 그러니까 main()같은건 없고 필요할때 실행되고 사라지는 스크립트들의 집합이라고 보면 된다. 오히려 웹 페이지
	자체가 main()이라고 봐야 할 지경. JavaScript는 C에서 영향을 받은 C-Family 언어로 기본적인 문법이 유사
	중괄호로 구분하는 블럭, 세미콜론으로 줄이 끝남을 알리는 것[15], 변수 쓰는 법, 연산자 사용법 등 기초적인 문법이 C
	문법과 크게 다르지 않다. 호이스팅 같은 것도 C언어의 잔재이다. 무엇보다 다른언어 쓰다온 사람들을 힘들게 하는건 클래스와
	메소드가 외관으로 구분이 안된다라는 점이다. JavaScript에서도 함수형[16] 언어의 불편함과 호이스팅 등 여러 문제를
	무마하기 위해서 클래스 개념의 도입과 변수 선언을 let[17], const[18]로 하는 등 다른 언어 쓰는 사람들의 적응을
	돕도록 흉내는 내 주는 척하는게 다행. 물론 일반적인 객체 지향 프로그래밍 개발자에게는 이것마저 이해를 못 하고 Syntatic
	Sugar에 불과한 JavaScript의 클래스를 불만족스러워한다. JavaScript는 멀티-패러다임 언어로 명령형, 함수형,
	객체 지향형 언어다. 기본적으로는 함수가 일급 시민으로 취급되는 언어로써 함수형 프로그래밍 패러다임을 따른다. 자연스럽게 이는
	클로저로 시작해 끝을 보는 것이 가능하다.[19] 멀티 패러다임 언어인만큼 원한다면 명령형 프로그래밍(imperative
	programming)으로 코드를 쓸 수도 있지만 보통은 함수형/선언형 프로그래밍으로 작성해야 JavaScript가 제공하는
	장점을 백분 활용하는 것이 가능하다. 객체 지향으로 코드를 작성하는 것도 가능하고 심지어 class도 ECMAScript
	6이후로 제공하지만, JavaScript에서의 class는 그냥 function을 class형식으로 쓸 수 있게 제공하는
	syntatic sugar에 지나지 않으므로 타 객체 지향 프로그래밍 언어처럼 사용하다가는 장벽에 부딪히기 쉽다. 즉
	JavaScript에서 class는 존재하지만 C++의 class와는 완전히 다른 개념이며, JavaScript의 객체 지향
	프로그래밍은 함수 프로토타입에 기반한 객체 지향 프로그래밍이다. # 결국 근본적으로 JavaScript는 함수와 함수형
	프로그래밍을 제대로 이해하지 않으면 제대로 다룰 수 없는 언어인 셈이다. 이런 특징 때문에 for이나 while 등의 loop은
	특수한 경우를 제외하고는 쓰이지 않으며, 어떤 동작을 수행시키는 데 있어서 JavaScript에서 제공되는 prototype
	function에 콜백함수를 제공하여 선언적으로(declarative programming) 코드를 작성하게 된다. 일반적으로
	대학교에서 C++ 등으로 프로그래밍을 시작한 사람이라면 이런 코딩 스타일에 익숙해지는 데 시간이 걸리지만, 한번 익히고 나면
	매우 간단명료하게 코드를 쓸 수 있다는 점, 언제나 Immutability가 보장된다는 점, 순수 함수(Pure
	Function)을 기반으로 코드가 작성되기 때문에 예상치 못한 버그가 최소화된다는 점 등이 매력적인 요소가 정말 많은
	프로그래밍 패러다임이다. 2010년 후반 들어서는 RxJS라는 라이브러리를 기반으로 한 반응형 프로그래밍이 등장했다. 함수형
	프로그래밍과 매우 흡사하지만 여기에 이벤트와 데이터 스트림(Observable)을 기준으로 사고하는 것을 더한 프레임워크로,
	side effect 수행 및 asynchronous operation에 있어서 매우 장점이 많아 대세로 떠오르고 있다.

	JavaScript는 동적 타이핑, 약타입 언어고[20], 간단한 문법에 코딩 방법이 비교적 유연하기 때문에 초기 진입장벽이
	거의 없어서 쉽다고 이야기 되지만, 깊이 들어가 보면 매우 변태적인 특이한 언어이자 매우 우수한 설계를 자랑하는 강력한
	언어이다. 편하면서도 강력한 텍스트 표기법(JSON(JavaScript Object Notation))[21]을 가졌으며,
	구조적으로 비동기 프로그래밍에 유리하다. 이러한 비동기 프로그래밍에 특화된 특징은 이후 Node.js를 탄생시키며
	JavaScript라는 언어의 사용 반경을 폭발적으로 늘리는 데 기여하게 된다. 진입 장벽은 낮지만[22] 실제 사용하려면 모든
	언어가 그렇듯 어렵다. 특히 다른 언어와 비교했을 때 상상도 못할 독특한 특징들이 많은 언어이다. 가장 대표적인 것이
	객체(Object)의 상수(const) 개념이다. 객체의 경우 상수로 선언해도 메모리값만 상수일 뿐 객체 안의 내용은 변경이
	가능하다. 즉 객체가 저장된 공간을 가리키는 정보만 상수일뿐 그 객체의 정보 자체는 변경이 가능하다. 배열도 마찬가지. 이런
	이유로 JavaScript에서 객체는 변수로 선언할 이유가 없으며 거의 모든 케이스에서 상수로 선언하는게 일반적이다. 또 이렇게
	상수로 선언된 객체의 Immutability를 보장하기 위해 여러 테크닉이 쓰이게 되는데 주로 ECMAScript 6에서 도입된
	Spread Operator를 사용하는 것이 일반적이다. 이렇게 객체를 복사하여 사용할 때도 Deep clone하지 않으면
	의도치 않게 원본 객체가 변경되어버리기 때문에 많은 주의가 필요하다. 또한 비동기로 작동되는 코드가 많아 코드 위에서부터
	차근차근 실행되는 게 아니라는 점 또한 JavaScript를 마스터하는 데에 넘어야할 장벽 중 하나이다. 이 때문에 특히
	Side effect 수행이 요구되는 상황에서 절차적으로 원하는 바를 수행하도록 만들기 위해서 간단하게는 promise나
	callback을 사용하는 방법에서부터 복잡하게는 반응형 프로그래밍 라이브러리도 사용할 수 있는 등 여러 테크닉이 요구된다.
	이런 독특한 특징들 때문에 타 주류 언어와는 또 다른 사고방식을 요구한다. 복잡한 side effect 수행에 있어서 예상치
	못한 버그를 유발하는 등 개발자에게 많은 피로감을 안겨주는 특징이지만 이러한 비동기 오퍼레이션은 JavaScript의 높은
	퍼포먼스를 지탱하는 주요한 특징 중 하나이다. 짧은 동작들의 경우 절차적 프로그래밍을 해도 잘 돌아가는 것처럼 보이지만 긴
	코드를 짜보면 의외로 골치 아프다.[23] 예를 들어 웹 브라우저나 Node.js 서버에서도 JavaScript의 비동기
	프로그램 작성시에는 스레드를 분기하여 작업을 분산 처리하거나, 코루틴으로 작업을 대기 시키는 대신 컨티뉴에이션(+타이머)만
	이용해 비동기 프로그램을 구현한다. 즉 싱글스레드 위에 시분할만 존재하고 1 프로세스 1 스레드로 작동한다[24]. 스레드
	분기와 코루틴 같은 추상화 된 비동기 처리 자원에 익숙한 프로그래머들이라면 이러한 방식으로 인하여 꽤 고생할 수 있다.[25]
	특히 람다식이 여러 번 중첩되는 고차 함수는 그야말로 아스트랄의 극치. 정작 Java는 람다식을 8버전에서야 지원한다...
	게다가 호이스팅이라는, 특정 조건 하에서 선언하는 순서와는 다르게 변수 및 함수를 할당하는 특성이 있다. 이를 방지하기 위해서
	const나 let를 주로 쓴다. 보통 불변성이 있는 const를 더 사용하는 편. 다만 위에서 언급된 코루틴은
	ECMAScript 6, 즉 2015년도 표준에 이미 포함되어 있는지 오래다. 보통 코루틴이 아닌 Promise라고 부르다 보니
	둘이 같은 것이라는걸 모르는 사람도 있는 편. 또한 병렬적 실행도 Promise.all로 동시 실행이 가능하게 되었다.[26]

	2010년대 중반 이후 JavaScript는 구글의 V8 JavaScript Engine 버프를 받아 하루가 다르게 발전하고
	있으며 이러한 모양새는 다음 글에서도 잘 나타난다. 2016년에 JavaScript를 배우는 기분 개발자들 사이에서 이런
	발전상이 화제가 되기도 했다. 과거에는 브라우저 환경에서만 사용이 가능한 웹 전용 프론트엔드 프로그래밍 언어에 불과했지만,
	현재는 Node.js라는 강력한 Runtime Environment의 등장으로 백엔드 언어로써도 매우 강력한 성능을 가진 언어로
	재탄생했으며 실제로도 백엔드 분야에서 빠르게 점유율을 높여가고 있다. Node.js 서버는 확장성이 높고 개발자 입장에서도
	JavaScript만 알면 접근이 가능해 유지보수 측면에서도 유리한면이 있고 무엇보다 I/O가 자주 이루어지는 애플리케이션의
	경우 성능이 매우 좋다. 여기에 ORM까지 등장하면서 심지어 데이터베이스 시스템이 제공하는 Stored Procedure까지도
	대체가 가능한 수준까지 이르렀다. 이와 동시에 백엔드 및 프론트엔드 양방향에서 정말 수많은 라이브러리가 등장하면서 발전이
	가속화되는 중이다. '여기에 HTML5, 반응형 웹 등 다양한 웹 기술의 발달로 인해 사실상 데스크탑 애플리케이션이 쇠퇴하고
	웹이 모던 애플리케이션의 표준이 되면서 중요성이 더욱 두드러지는 언어가 되었다. 실제로 많은 소프트웨어 회사들이 기존 C++나
	Java 등으로 쓰여진 PC용 애플리케이션을 웹앱으로 전환하고 있어[27] 수요도 많고 전망 또한 밝은 언어라 할 수 있다. 이
	때문에 현재 JavaScript는 확장성이 매우 높은 언어이다. JavaScript만 알면 일반적인 사이트 개발부터
	React.js 또는 Vue.js를 사용해 SPA 웹사이트 개발, iOS와 안드로이드 앱을 만들수 있는 React Native,
	웹서버나 다른 서버 사이드 애플리케이션에 Node.js, 데스크탑 앱은 리눅스, macOS, 윈도우, tvOS 등 플랫폼에서
	사용 가능한 Electron을 이용하거나 React Native for Windows를 사용해 Windows 10 SDK까지
	접근할수 있다. 과거 프론트엔드 언어로만 JavaScript가 쓰였을 때 가장 유명했던 라이브러리로는 jQuery가 있었다. 잘
	익혀두면 직접 짜는 것보다 꽤 간단하게 기능을 불러 쓸 수 있어 대학에서도 가르쳤던 필수 라이브러리였다. 하지만 React나
	Vue.js, 혹은 Angular가 등장한 이후로 모듈형 개발이 순식간에 대세가 되었고, 이는 jQuery 대비 비교도 안될
	정도로 월등하게 생산성이 높기 때문에 현재로서는 jQuery 자체가 모던 웹 애플리케이션 개발에는 더이상 사용되지 않는 기술이라
	생각하면 된다. 원한다면 다른 프레임워크에 jQuery 라이브러리도 병행해서 사용할 수도 있으나, 그럴 바에야 그냥 직접
	querySelector를 사용해서 DOM을 업데이트하는 게 낫기 때문에 정말 간단한 애플리케이션이 아니면 사용할 이유가
	없어져버렸다. 사실 jQuery 같은 라이브러리는 2000년대에 각 브라우저마다 JavaScript 문법이 달랐던 대혼돈의
	시대에 문법을 통일시켜보자는 취지로 나온 거라 표준 문법이 정착되고 IE가 완전히 도태된 2022년 시점에서는 더 이상 쓸
	필요는 없다. 대세가 된 React나 Vue.js의 경우 단독으로 사용되는 경우는 드물며 Redux나 Mobx같은 상태관리
	라이브러리를 같이 사용하여 개발한다. 상태관리 라이브러리를 사용하지 않아도 개발은 충분히 가능하나 매우 비효율적이라 규모가 큰
	애플리케이션의 경우 사실상 개발 자체가 불가능하다고 보면 된다. 상태 관리를 위한 방법론은 다음과 같은 것이 존재한다.
	Redux: 페이스북에서 리액트를 위해 만든 아키텍처인 Flux에 영향을 받아 댄 아브라모프가 만들어낸 아키텍처 및 이를 구현한
	상태 컨테이너. React의 아키텍처에 영향을 받았지만, 그 자체로 상태 관리를 사용할 수 있기 때문에 다양한 프레임워크와 함께
	사용할 수 있다. 상태 관리를 위한 방법이 다양하지 않았을 때 나타나 높은 점유율을 차지하였지만, 2022년 현재 다양한 상태
	관리 라이브러리가 나오면서 점유율이 조금씩 줄고 있다. 각각의 상태를 위해서 Reducer와 Action을 복잡하게 정의한
	뒤에야 사용할 수 있다는 것이 단점으로 꼽힌다. context + useReducer: React 내부적으로 이후에 전체적인
	상태 관리가 필요함을 인지하고 추가하였다. useReducer는 Redux 아키텍처의 Reducer와 유사하게 작동한다고
	생각하면 대충 맞다. 소규모 웹앱에서 상태 관리를 위한 라이브러리를 사용하지 않기를 원한다면 고려할 수 있는 옵션이다. 다만,
	이를 이용할 경우 리듀서가 제대로 작동하기 위해서는 다양한 최적화 작업을 해야하므로 대규모 환경에서 추천하기 어렵다.
	Recoil: 페이스북에서 결국 체계적인 상태 관리를 위해서 만들었다. 2022년 기준 아직 기능이 완전하지는 않지만 리액트
	제작자가 만들었다는 이유로 많은 기대를 받는다. 관련 책으로는 Douglas Crockford의 JavaScript 오브젝트
	생성 패턴, JavaScript: The Good Parts(JavaScript 핵심 가이드) 매우 얇은 게 함정 , 카일
	심슨의 You don't know JS(원문)이 있다. 이래도 저래도 이해가 안된다? htm 파일이 main함수고 존재하는 모든
	위젯(라디오버튼,체크박스 등)이 클래스, 거기에 메소드가 딸린거라 생각하자.

	<h1 id="java">Java</h1>
	Java의 가장 큰 특징은 플랫폼에 독립적인 언어라는 점이다. 소스 코드를 기계어로 직접 컴파일하여 링크하는 C/C++의
	컴파일러와 달리 자바 컴파일러는 바이트코드인 클래스 파일(.class)을 생성하고, 이 파일의 바이트코드를 읽은 뒤 기계어로
	바꾸어 실행하는 것은 자바 가상 머신이다. 예를 들어 플랫폼에 종속된 경우 윈도우에서 빌드한 프로그램을 그대로 리눅스나
	macOS에서 실행하려 하면 일반적으로 오류가 나지만 Java로 작성 된 프로그램은 플랫폼에 맞는 Java Runtime
	Environment만 설치되어 있다면 문제 없이 동작한다. 이는 Java 코드 자체가 플랫폼이 아닌 가상머신에 종속적이라는
	점, 그리고 프로그램 실행의 주체가 운영 체제가 아닌 Java Runtime Environment이라는 점 때문이며 이러한 점을
	통틀어 Java는 플랫폼 종속성이 낮은 언어라고 표현한다. Java Runtime Environment 기반의 프로젝트에서는
	하나의 언어만을 고집하지 않는다. 함수형 언어가 유리(최근 유행하는 빅데이터 등)한 부분은 Scala로 작업하며, 견고한
	인터페이스와 대규모 통합이 필요한 곳은 Java로 작업한 뒤 이들을 서로 합쳐서 운영하는 게 가능하다. (Java에서 만든
	객체를 Scala에서 그대로 사용할 수 있다.) 안드로이드 쪽에서는 크리티컬하지 않은 부분부터 Kotlin으로 코드를 교체하는
	경우도 많아지고 있다. 실제 현업에서는 Java를 비롯한 여러가지 인기 언어가 자주 사용되므로 장단점을 잘 알아두는게 좋다.
	다른 언어에 대해 맹목적으로 찬양/비판하는 태도보다는 환경이나 주어진 작업의 특성에 따라 적합한 언어를 선택할 수 있는 노하우가
	필요하다. 간혹 파이썬을 처음 배우는 경우도 있지만 아직까지는 컴공 비전공자들이 일반적으로 처음 배우게 되는 언어다. 대한민국의
	대부분, 특히 공공기관 쪽의 프로젝트는 백이면 백 Java를 사용하기 때문에 실무 투입에 유용해 전문학교 단골 언어다. 교육생
	입장에서는 현장에서 안 쓰는 언어를 교육용으로 배우는 것은 쓸데없어 보이니 수강을 거부한다. 교육기관은 교육생의 요구에도
	맞춰줘야 하고, 교육용 언어와 실무용 언어 두 종류를 가르치기보다는 실무용 언어 하나만 가르치는 것이 최단 기간에 진도를 빨리
	뺄 수 있으니 실무용 언어부터 가르치려고 한다. 그러나 Java를 배웠으니 무조건 취직을 할 수 있을 것이라고 생각하는 것은
	금물이다. 잡코리아나 사람인에서 Java라고 검색만 해보면 알 수 있는 사실이 있는데 구인광고에서 Java 하나만을 요구하는
	회사는 거의 없다. Node.js, AngularJS, jQuery, JSTL, .NET 등등 다른 언어를 추가로 요구하는
	회사는 심심하면 나타나는 수준이고, 심하면 Java는 자격요건에 나와있지도 않는 경우가 있다. Java는 기본이고
	Node.js, JQuery 등을 알고 있는지 모르는지로 취직이 되냐 안 되냐가 결정되는 것이다. 개발하는 데 있어 당연히
	Java 하나만을 사용하지는 않고 비슷한 여러 언어를 같이 쓰기 때문이다. 자격요건으로 적힌 언어는 그 회사에서 주로 사용하는
	언어를 적어놓기 때문에 해당 언어의 기본 문법 정도는 알면 취업에 도움이 될 것이다. 권장 요건에 불과하기 때문에 적힌 내용 중
	조금만 안다고 해도 뽑힐 수 있다. Java는 객체지향 언어이기 때문에 소스를 보면 직관적으로 눈에 들어온다. 메서드[21]를
	보면 이 메서드가 무슨 역할을 하는지 이 변수가 어디에서 사용되는지 등이 한눈에 들어오기 때문에 이해하기가 쉽다. 그리고
	Java는 너무나도 유명하기 때문에 가능한한 쉽게 설명해주는 강의들도 많으니 인터넷에서 검색하면 쉽게 배울 수 있다. 또한
	객체가 무엇인지만 알면 Java로 코딩하는데에 어려움은 적다. 한편 Java는 다른 언어에 비해 코드량이 더 많다. 이에 대해
	아래쪽 문단에서 주장하는 것처럼 Java에 대해서 이상할 정도로 부정적으로 생각하기도 하고, Java가 다른 언어에 비해
	코드량이 더 많은 것을 단점으로 치부하기도 한다. 확실히 Java는 다른 언어에 비하면 쳐야하는 코드가 더 많지만 그것을
	개발자가 일일이 치지는 않는다. IDE의 자동완성을 쓰면 쉽게 해결될 문제라서 실무에서는 아무 문제가 안 된다. 개발 속도
	외에도 정확성 문제 때문에 자동완성이 우월하다. 사람이 치면 정말 타자 실력이 뛰어나지 않고서야 오타가 발생하게 되어 있다.
	하지만 자동완성을 사용하면 이름을 지어줘야 할 때 빼고는 오타가 생길 일이 거의 없다. 논리적 에러보다는 오타로 인해서 에러가
	생기는 경우가 일상다반사이다. 출력 메서드 이름이 제일 길다고 하는데 IntelliJ IDEA의 경우 sout이라고만 치면
	System.out.println();이 자동으로 완성된다. 이클립스의 경우 syso를 치고 ctrl+space를 누르면 된다.
	그리고 이러한 자동완성 기능은 메소드의 호출이나 객체 생성 등 내가 지금 작성하는 코드가 올바른지 실시간으로 확인해주는
	역할이라고도 할 수 있다. 올바르지 못한 코드를 작성하면 자동완성 기능이 동작하지 않을 것이기 때문이다. 아래 문단을 보면
	초보자에게 IDE를 주는 걸 부정적으로 말하고 있는데 대부분의 유명 IDE는 직관적인 GUI를 지원하므로 단축키나 복잡한 기능
	하나하나를 외울 필요 없이 보이는대로 클릭해서 실행시킬 수 있다. 순수하게 텍스트 편집 기능만 제공하는 vim과, 잘못된 코드
	구조를 분석하여 컴파일하기 전에 경고를 띄우고 올바른 예시 코드로 리팩토링해주는 IntelliJ IDEA 중 어느 쪽이 초보자
	입장에서 쉽고 생산적일지는 굳이 따질 필요가 없을 것이다. 때때로 IDE의 기능에서 벗어나 프로그래머가 직접 튜닝을 해야 하는
	복잡한 상황이 생길 수는 있으나, 이것 역시 초보자에게 해당되는 이야기는 아니다. 프로그래밍에 있어 중요한 것 중 하나는 얼마나
	코드를 논리적으로 최소화시킬 수 있냐는 것인데 이것을 단순히 코드량이 적을수록 좋다고 생각하는 것은 어리석은 생각이다.
	코드량보다는 얼마나 쓸데없는 코드를 제거할 수 있는지가 중요한 것이다. 그리고 쓸데없는 코드를 제거하고도 코드량이 많은 경우는
	얼마든지 있다. 왜냐면 실무에서 사용되는 코드는 적게 잡아도 몇백 줄이고 보통은 몇천 줄 이상이다. 그것도 파일 하나 당.
	그것을 코드량이 많다고 해서 안 좋은 코드라고 볼 순 없다. 우리가 말을 할 때 명사와 동사의 기본형만 가지고 말을 해도 말은
	통한다. 하지만 그 말을 우리가 효율적이라고 생각하는지, 실제로 그렇게만 말하는지 생각해보면 단순히 코드량으로 효율을 따지는
	것이 옳기만 한 것인지 답이 나온다. 프로그래밍 '언어'라는 것을 다시 한번 생각해볼 필요가 있다. '좋은 말'이란 너무 짧아서
	알아듣기 힘든 말이 아니라 군더더기가 없는 말이며 이것이 뜻을 전달하는 데 있어 가장 좋은 말이라는 것에 동의할 것이다. 물론
	Java가 쉽다고는 할 수 없다. Java는 객체 지향 프로그래밍 언어이기 때문이다. 객체지향적으로 프로그래밍하는 방법을
	물어보면 대부분의 개발자들이 모른다고 할 것이다. 정말 어려운 개념이기 때문에 전문적 연구자가 아닌 한 객체지향이라는 개념에
	대해 실질적, 구체적으로 정의할 수 없다. 사전적 정의는 누구나 말할 수 있지만 어디까지나 사전적 정의일 뿐이다. 이렇게 어려운
	개념이라고 해서 너무 걱정하지는 않아도 괜찮다. 객체지향이라는 것을 조금이나마 이해하고 있다면 당신은 전혀 신입 개발자가
	아니라는 뜻이니까. 그리고 아래쪽 문단에서 추천하는 Python도 결국 현업에서는 OOP 언어로 활용한다.

	<h1 id="python">Python</h1>
	Python의 아이덴티티. 높은 생산성은 그 무엇과도 비교할 수 없는 Python만의 특징이다. 전 세계의 모든 프로그래밍 언어
	중에서 Python 정도의 낮은 난이도를 가지면서, 오만가지 분야에서 생산된 훌륭한 패키지들을 통해 범용성까지 갖춘 프로그래밍
	언어는 찾기 힘들다. Python으로 만든 프로그램을 같은 객체 지향 프로그래밍 언어인 Java나 C++로 만드려는 순간 숨이
	턱 막힐 정도. 이런 언어들을 사용하려면 설계부터 난감해진다. 인터프리터 언어이면서 우수한 자료형과 다양한 모듈 등을 제공해
	개발 기간이 단축되는 것이 특징. Python이 막 유행을 타기 시작했을 때에는 'C언어로 2년 동안 완성하지 못한 프로젝트를
	Python으로 한 달 만에 해냈다'는 극적인 경험담이 커뮤니티에 돌았을 정도다. 당장 Python의 집합 자료형 같은 경우
	C언어로 구현하려고 하면 머리가 아파 온다. C언어와의 접착성도 좋기 때문에, 일단 Python으로 빨리 구현하고, 남은 시간에
	속도에 병목이 되는 부분을 C++로 전환하는 전략을 내세우고 있다. 버전이 올라가면서 Python 자체도 그리 느리지 않게
	되었다. 심지어 어셈블리어 같은 저수준 언어(Low level)도 Python에서 호출할 수 있다. Python은 어지간한 다른
	프로그래밍 언어들을 지원하는 호환성 덕분에 응용할 곳이 무궁무진하다.실행 속도만 빼고 개발 속도가 빠른 데에는 친절한
	Traceback도 한몫한다. 코드를 실수로 잘못 짠 곳이 있다면, 어떤 스택을 통해 어떤 어떤 파일의 어떤 줄에서 어떤
	함수에서 어떤 종류의 문제가 발생했는지 아주 자세하게 알려준다. 스택을 전부 보여주기 때문에 초보자에게는 당황스러울 수 있지만,
	디버깅을 하다 보면 정말 편리하다. 아래는 오류(Exception) 발생 시의 터미널 출력 예시다. Python을 많이 쓰는
	곳에 취직하고 싶으면 파이썬을 공부하는 식으로 언어를 선택해도 상관은 없다. 단, 취직이 될 경우에 한해서이다. 파이썬이 많이
	쓰이기도 하고 Java에 비해서 쉽다고는 하지만 대한민국의 현실상 파이썬의 비중이 높은 회사가 아니고서야 취직하기가 어렵다.
	당장 공공기관만 하더라도 Java를 쓰고 있고 해당 공공기관의 피고용인 입장인 회사들(을), 그 하청업체 회사들(병)이 많기
	때문에 Java 일자리가 훨씬 많다. 그리고 SI에 대해서 들어본 적이 있다면 알고 있을 SI의 피라미드 구조를 생각해보면,
	대한민국에서 Java나 C/C++는 배우지 않은 상태에서 다른 언어만 배웠을 때 취직할 가능성이 얼마나 낮은지 알 수 있을
	것이다. 이러한 현실에서도 파이썬을 배워서 취직하고 싶으면 해외로 눈을 돌리는 것이 좋다. 파이선은 자바나 C 언어보다 입문하기
	쉽다. 한국의 컴퓨터 교육 현장에서 무작정 자바와 C를 주입하면서 수많은 낙오자가 발생하고 있으며, 간신히 통과한다 해도 기본을
	닦지 못한 코더가 양산될 뿐이다. 그래서 전체적인 프로그래머 인력 풀의 질과 양 둘 다 떨어뜨리는 악영향을 끼치고 있다.
	실제로는 첫 언어만 Python으로 바꿔도 쉽게 갈 수 있다. 그나마 Python이 인지도를 많이 넓혀놔서 2019년 현재는
	상황이 많이 나아지긴 했다. C언어를 만든 목적은 유닉스 운영 체제에서 사용하기 위해서이다. 언어 설계자의 기본 가정이 C를
	사용할 사람은 이미 컴퓨터 아키텍처의 세부사항을 잘 알고 있다는 것이었다. 그래서 C언어는 프로그래머가 이상한 짓을 해도 최대한
	그대로 하려고 들고, 명백하게 망가지기 전까지는 아무런 경고도 하지 않는다. C로 시작하는 데에 한 가지 문제가 더 있는데,
	한국 대학 교육 현실상 구세대 표준을 강요하는 곳이 적지 않다. Java 역시 객체지향 개념이 난해하고 언어가 장황해서 힘들다.
	먼저 Boilerplate 문제를 보자. 함수 하나, 연산식 하나를 테스트하려고 해도 public class GuguClass로
	시작하는 십여 줄의 코드를 일일이 작성해야 한다. 특히 화면 출력 메소드의 이름이 System.out.println이라는 긴
	이름이다.[22] 인기 있는 프로그래밍 언어 중에서 이 정도로 출력 메소드가 긴 언어는 Java가 유일하다. 이게 문제가 되는
	이유는 이제 막 코딩에 입문하는 초보자는 코드를 입력하는 과정에서 필연적으로 오타를 치게 되는데 자바는 이 오타 지점을 찾기가
	상대적으로 매우 어렵기 때문이다.[23] 거기다 문법이 쉽다-어렵다에 더해 한 가지 차이점이 더 있다. Python은 인터프리터
	언어고 C/C++/Java는 컴파일 언어다. 초심자는 인터프리터 언어부터 배우는 게 유리하다. 왜냐하면 인터프리터 언어는 코드의
	실행 결과를 즉시 확인해볼 수 있고, 컴파일 언어는 컴파일이 끝나야 결과를 확인할 수 있다. 컴파일 언어는 컴파일이 실패하면
	코드의 첫 줄도 실행할 수 없다. 컴파일 오류 메시지가 나오긴 하지만, 그 컴파일 오류 메시지를 해독해내는 시점에서 이미 초보가
	아니다. 이 때문에 초보자는 잘못된 곳을 찾기 위해 코드의 모든 줄을 검사해야 하고 심지어는 컴파일 명령 자체에 오타가
	있는지까지 확인해야 한다. 반면 인터프리터 언어는 에러가 나기 전까지는 코드를 꾸역꾸역 실행하므로 오류가 난 줄 바로 직전까지
	코드를 실행할 수 있다. Python 강의는 도처에 널렸으므로 적당한 강의 하나 골라잡고 따라하다보면 일단 코더 수준은 될 수
	있다. 80년대생 프로그래머는 BASIC부터 시작했던 경우가 많은데, 21세기의 Basic이라고 할 만한 것이 바로
	Python이다. 문법 자체도 영어로 글쓰듯이 만들어져 있어 접근성이 굉장히 높다. 영미권에서 먼저 배우는 이유가 그만큼 친숙한
	영어를 기반으로 되어있기 때문. 사실 미국에서 진짜 입문용으로 가르치는 것은 Scratch라는 언어인데, 이 스크래치는 철저히
	교육용이기 때문에 실용적인 프로그램을 만들기는 어렵다. Python은 매우 고성능이기 때문에 과거의 BASIC이나 오늘날의
	Scratch와 달리 입문 이후에도 주력으로 사용할 수 있다.
</body>
</html>